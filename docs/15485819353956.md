# 链表 

## 实现LRU缓存淘汰算法

缓存淘汰策略有三种: **先进先出策略FIFO、最少使用策略LFU、最近最少使用策略LRU**

## 基于单链表实现LRU缓存淘汰算法
维护一个有序的单链表，越靠近链表尾部的结点是越早访问的，当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后在插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况:

* 如果此时缓存未满，则将此结点直接插入到链表的头部；
* 如果此时缓存满了，则链表尾结点删除，将新的数据点插入到链表的头部。

## 引申问题

* 如果用数组来实现LRU算法。
* 判断一个字符串是否是回文字符串的问题。如果字符串是通过单链表来存储的，那么该如何判断是一个回文串呢？时间和空间复杂度是多少。
* [单链表反转](https://leetcode-cn.com/problems/reverse-linked-list/)
* 链表中环的检测
* 两个有序的链表合并
* 删除链表倒数的第n个节点
* 求链表的中间节点
* 两两交换链表中的节点
* 每k个节点一组翻转链表

## 解决方案
### 链表中环的检测
```
方法一:
一直顺着链表往下找，如果指向的下一个是null 说明没有环。
方法二：
用字典来存储每一个节点，如果节点有重复 说明有环。
方法三:
两个指针，一个快一个慢，快的走2步，慢的走1步，如果快的指针的下一个指针指向慢的就说明是有环。
```
### 两个有序的链表合并
