# 网络

##网络7层协议

* 应用层
* 表示层
* 会话层
* 运输层
* 网络层
* 数据链路层
* 物理层

其中应用层 = 应用层+表示层+会话层

##应用层（HTPPS/HTTP）

应用层的任务是通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程(进程:主机中正在运行的程序)间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中引用层协议很多，入域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。我们把应用层交互的数据单元称为报文。

应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用进程之间的这种通信必须遵守严格的规则，应用层的具体内容就是精确定义这些通信规则，应用层协议应当定义:
* 应用进程交换的报文类型，如请求报文和响应报文
* 各种报文类型的语法，如报文中的各个字段及其详细描述
* 字段的语义，即包含在字段中的信息的含义。
* 进程何时、如何发送报文，以及对报文进行响应的规则。

##运输层（TCP,UDP）

* 运输层为相互通信的应用进程提供逻辑通信。
* 端口和套接字的意义。
* 无连接的UDP的特点。
* 面向连接的TCP的特点。
* 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议。
* TCP的滑动窗口、流量控制、拥塞控制和连接管理。 

### 进程之间的通信
从通信和信息处理的角度看，**运输层向上面的应用层提供通信服务**，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用下三层的功能。                                          

### 运输层的两个主要协议

* 用户数据报协议UDP UDP在传输数据之前不需要先建立连接。
远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。
* 传输控制协议TCP 则提供面向连接的服务。
在传送数据之前必须先建立连接，数据传送借宿后要释放连接.TCP 不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免的增加了许多的开销。

##网络层（IP）

* TCP/IP 体系中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传达的分组可能出粗、丢失、重复和失序。进程之间的通信的可靠性由运输层负责。
*

##数据链路层

###数据链路层使用的信道主要有下面两种类型:
* 点对点信道
这种信道使用一对一的点对点通信方式
* 广播信道
这种信道使用一对多的广播通信方式。

##物理层
物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能的屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么。
可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即:
* 机械特性
* 电器特性
* 功能特性
* 过程特性


##TCP

###TCP特点

* TCP 是面向连接的运输层协议，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。
* 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的
* TCP提供可靠交付的服务，TCP链接传送的数据，无差错、不丢失、不重复、并且按序到达。
* TCP提供全双通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去，在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。
* 面向字节流。
流指的是流入到进程或从进程流出的字节序列，
TCP和UDP在发送报文时所采用的方式完全不同。TCP并不关心应用进程一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥挤的程度来决定一个报文段应包含多少个字节(UDP发送的报文长度是应用进程给出的)。如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些在传送，如果应用进程一次只发来一个字节，TCP也可以等待积累有足够多的字节后在构成报文段发送出去，
###TCP可靠传输的实现
为了讲述可靠传输原理的方便，我们假定数据传输只在一个方向进行，即A发送数据，B给出确认。这样的好处是讨论限于两个窗口，即发送方A的发送窗口和接收方B的接收窗口。
* 以字节为单位的滑动窗口
* 超时重传时间的选择
 1. TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文端。重传时间的选择确是TCP最复杂的问题
  TCP采用了一种自适应的算法，它记录了一个报文段发出的时间，以及收到相应的确认的时间。这两个时间只差就是**报文段的往返时间RTT**。TCP保留了RTT的一个加权平均往返时间RTTS
 1. 如何判定此报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？ 
 方法:报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为2倍的的旧的重传时间。
 Karn算法能够使运输层区分开有效和无效的往返时间样本，从而改进了往返时间的估测。
* 选择确认SACK
 接收方收到了报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传缺少的数据而不重传已经确认到达接收方的数据？答案是可以的，选择确认就是一种可行的处理方法。

###TCP的流量控制
一般说来，我们总是希望数据传输得更快一些。但如果发送发把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。
##利用滑动窗口实现流量控制##
利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。
设A向B发送数据。在建立连接时，B告诉A 我的接收窗口 rwnd = 400 (这里rwnd表示receiver window)。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。
##必须考虑传输效率##
接收方等待一段时间，使的或者接收缓存已有足够空间容纳一个最长的报文段，或者等待接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送发通知当前的窗口大小。此外，发送放也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。上述两种方式可配合使用。使的在发送方不发送很小的报文段的同时，接收方也不要在缓存刚刚有一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。

###TCP的拥塞控制

###TCP的运输连接管理

  	
