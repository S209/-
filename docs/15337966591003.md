# 网络

##网络7层协议

* 应用层
* 表示层
* 会话层
* 运输层
* 网络层
* 数据链路层
* 物理层

其中应用层 = 应用层+表示层+会话层

##应用层（HTPPS/HTTP）

应用层的任务是通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程(进程:主机中正在运行的程序)间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中引用层协议很多，入域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。我们把应用层交互的数据单元称为报文。

应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用进程之间的这种通信必须遵守严格的规则，应用层的具体内容就是精确定义这些通信规则，应用层协议应当定义:
* 应用进程交换的报文类型，如请求报文和响应报文
* 各种报文类型的语法，如报文中的各个字段及其详细描述
* 字段的语义，即包含在字段中的信息的含义。
* 进程何时、如何发送报文，以及对报文进行响应的规则。

##运输层（TCP,UDP）

* 运输层为相互通信的应用进程提供逻辑通信。
* 端口和套接字的意义。
* 无连接的UDP的特点。
* 面向连接的TCP的特点。
* 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议。
* TCP的滑动窗口、流量控制、拥塞控制和连接管理。 

### 进程之间的通信
从通信和信息处理的角度看，**运输层向上面的应用层提供通信服务**，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用下三层的功能。                                          

### 运输层的两个主要协议

* 用户数据报协议UDP UDP在传输数据之前不需要先建立连接。
远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。
* 传输控制协议TCP 则提供面向连接的服务。
在传送数据之前必须先建立连接，数据传送借宿后要释放连接.TCP 不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免的增加了许多的开销。

##网络层（IP）

* TCP/IP 体系中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传达的分组可能出粗、丢失、重复和失序。进程之间的通信的可靠性由运输层负责。
*

##数据链路层

###数据链路层使用的信道主要有下面两种类型:
* 点对点信道
这种信道使用一对一的点对点通信方式
* 广播信道
这种信道使用一对多的广播通信方式。

##物理层
物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能的屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么。
可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即:
* 机械特性
* 电器特性
* 功能特性
* 过程特性

##UDP
* UDP是无连接的 即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
* UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
* UDP是面向报文的。
* UDP没有拥塞控制的。
* UDP支持一对一、一对多、多对一和多对多的交互通信。
* UDP的首部开销小。

##TCP

###TCP特点

* TCP 是面向连接的运输层协议，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。
* 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的
* TCP提供可靠交付的服务，TCP链接传送的数据，无差错、不丢失、不重复、并且按序到达。
* TCP提供全双通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去，在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。
* 面向字节流。
流指的是流入到进程或从进程流出的字节序列，
TCP和UDP在发送报文时所采用的方式完全不同。TCP并不关心应用进程一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥挤的程度来决定一个报文段应包含多少个字节(UDP发送的报文长度是应用进程给出的)。如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些在传送，如果应用进程一次只发来一个字节，TCP也可以等待积累有足够多的字节后在构成报文段发送出去，
### 可靠传输的工作原理
* 停止等待协议
1. 无差错情况
A发送分组M1，发完就暂停发送，等待B确认。B收到了M1就向A发送确认。A在收到了对M1的确认后，就在发送下一个分组M2。
![无差错图片](media/15337966591003/%E6%97%A0%E5%B7%AE%E9%94%99%E5%9B%BE%E7%89%87.jpg)
2. 出现差错
如上图所示。B收到M1时检测出了差错，就丢弃M1，其他什么也不做(不通知A收到有差错的分组)。也可能是M1在传输过程中丢失了，这时B当然不知道。在这两种情况下，B都不会发送任何消息。可靠传输协议就是这样设计的:A只要超过一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因为重传前面发送过的分组。这就叫做超时重传。要实现超时重传，就要在每发送完一个分组设置一个超时计时器。如果在超时计时期到期之前收到了对方的确认，就撤销已设置的超时计时器。
3. 确认丢失和确认丢失
 B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，但并无法知道是自己发送的分组错误、丢失，或者是B发送的去人丢失了。因此A在超时计时器到期后就要重传M1。现在应注意B的动作，假定B又收到了重传的分组M1，这时应采取两个行动。
 第一、丢弃这个重复的分组M1
 第二、向A发送确认，不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到对M1的确认。
![确认丢失和确认迟到](media/15337966591003/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.jpg)

* 连续ARQ协议

###TCP可靠传输的实现

为了讲述可靠传输原理的方便，我们假定数据传输只在一个方向进行，即A发送数据，B给出确认。这样的好处是讨论限于两个窗口，即发送方A的发送窗口和接收方B的接收窗口。
* 以字节为单位的滑动窗口
* 超时重传时间的选择
 1. TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文端。重传时间的选择确是TCP最复杂的问题
  TCP采用了一种自适应的算法，它记录了一个报文段发出的时间，以及收到相应的确认的时间。这两个时间只差就是**报文段的往返时间RTT**。TCP保留了RTT的一个加权平均往返时间RTTS
 1. 如何判定此报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？ 
 方法:报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为2倍的的旧的重传时间。
 Karn算法能够使运输层区分开有效和无效的往返时间样本，从而改进了往返时间的估测。
* 选择确认SACK
 接收方收到了报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传缺少的数据而不重传已经确认到达接收方的数据？答案是可以的，选择确认就是一种可行的处理方法。

###TCP的流量控制

一般说来，我们总是希望数据传输得更快一些。但如果发送发把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。

##利用滑动窗口实现流量控制##

利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。
设A向B发送数据。在建立连接时，B告诉A 我的接收窗口 rwnd = 400 (这里rwnd表示receiver window)。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。

###必须考虑传输效率###

接收方等待一段时间，使的或者接收缓存已有足够空间容纳一个最长的报文段，或者等待接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送发通知当前的窗口大小。此外，发送放也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。上述两种方式可配合使用。使的在发送方不发送很小的报文段的同时，接收方也不要在缓存刚刚有一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。

###TCP的拥塞控制

###TCP的运输连接管理
1. 连接建立
![三次握手](media/15337966591003/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg)

2. 为什么要三次握手，两次或者四次。
为什么A还要发送一次确认呢? 这主要是为了防止已失效的连接请求报文段突然有传送到了B

案例
A发送连接请求，但是没有收到B的确认，于是A再重传一次连接请求。后来收到了确认，建立连接，数据传输完毕后，就释放了连接，A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。
现在假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某网络结点长时间滞留，以致于延误到连接释放以后的某个时间才到达B。本以为这是一个早已失效的报文段，但B收到此失效的链接请求报文段后，就误以为A又发送一次新的链接请求，于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立。
由于A并且没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B确认已新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。


  	
