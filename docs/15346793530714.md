# git

#git 基础要点

#安装 git
#初次运行git前的配置
# git基础
## 检查当前文件状态
要确认哪些文件当前处于什么状态，可以用 git status命令。
![00_41_53__08_21_2018](media/15346793530714/00_41_53__08_21_2018.jpg)
```
 $git status
```
## 跟踪新文件
```
 $ git add README
```
此时再运行 git status 命令，会看到文件被跟踪了，并处于暂存状态。
```
$ git status
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage) #
# new file: README #
```
只要在 "Change to be committed" 这行下面的，就说明是已经暂存状态。如果此时提交，那该文件此时此刻的版本将被留在历史记录中，

##暂存已修改文件
现在我们修改下之前已跟踪的文件，再次运行status命令，会看到这样的状态报告：
```
$ git status
# On branch master
# Changes to be committed:
# (use "git #
# new file: #
# Changed but
# (use "git #
# modified:
#
reset HEAD <file>..." to unstage) README
not updated:
add <file>..." to update what will be committed)
benchmarks.rb
```
文件出现在 "Changed but not updated" 这行下面，说明已跟踪文件的内容发生了编码，但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令。
```
$ git add benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage) #
# new file: README
# modified: benchmarks.rb
```
现在两个文件都已经暂存，下次提交时就会一并记录到仓库。假设此时，你想要在文件里面添加条注释，重新编辑存盘后，准备好提交。不过且慢，在运行 git status 看看:
```
$ vim benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
# (use "git #
# new file:
# modified:
#
# Changed but
# (use "git #
# modified: #
```
见鬼，benchmarks.rb 文件出现了两次，一次算未暂存，一次已暂存，这怎么可能。实际上
git 只不过暂存了你运行 git add 命令的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本，所以，运行了git add 之后又做了修改的文件，需要重新运行 git add 把最新版本重新暂存起来。
```
$ git add benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage) #
# new file: README
# modified: benchmarks.rb #
```
## 忽略某些文件
一般我们总会有些文件无需要纳入git 的管理，也不需要他们总出现在未跟踪的文件列表，通常都是些自动生成的文件，像是日志或者编译过程中的创建的等等，我们可以创建一个名为.gitignore的文件，列出需要忽略的文件模式，来看一个简单的例子:

```
$ cat .gitignore *.[oa]
*~
```
第一行是告诉git 忽略所有以.o 或者.a结尾的文件，

```
# 此为注释 – 将被 Git 忽略
*.a # 忽略所有 .a 结尾的文件
!lib.a # 但 lib.a 除外
/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
```
## git查看已暂存和未暂存的更新
git diff 可以查看到当前哪些更新还没有暂存，有哪些更新已经暂存起来准备好了下次提交，git diff 会使用文件补丁的格式显示具体添加和删除的行。
假如再次修改 README 文件后暂存，然后编辑 benchmarks.rb 文件后先别暂存，运行 status 命令，会看到:
```
diff --git a/docs/15344337995634.md b/docs/15344337995634.md
index bed0f1b..7802ea8 100644
--- a/docs/15344337995634.md
+++ b/docs/15344337995634.md
@@ -1 +1,3 @@
-# iOS 逆向工程
\ No newline at end of file
+# iOS 逆向工程
+## 逆向工具详解
+                         
\ No newline at end of file
diff --git a/docs/15346793530714.md b/docs/15346793530714.md
index 7451b1a..83eff50 100644
--- a/docs/15346793530714.md
+++ b/docs/15346793530714.md
@@ -5,6 +5,103 @@
 #安装 git
 #初次运行git前的配置
 # git基础
+## 检查当前文件状态
+要确认哪些文件当前处于什么状态，可以用 git status命令。
```
```
git diff : 查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff
git diff --cached :若要看已经暂存起来的文件和上次提交的时候快照之间的差异，
```
##移除文件
要从git 中移除某个文件，就必须要从已跟踪文件清单中移除(确切的说，是从暂存区域移除)，然后提交，可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中。
```
$git rm grit.gemspec
```
另外一种情况是，我们想把文件从Git 仓库中删除(从暂存区域移除)，但任然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除
```
$git rm --cached readme.txt
```
##移动文件
git 修改某个文件名
```
$git mv file_from file_to
```
其实运行 git mv 就相当于运行了下面三条命令
```
$ mv file_from file_from
$ git rm file_from
$ git add file_from
```
## 撤销操作
有些操作并不总是可以撤销的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。
### 修改最后一次提交
有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。想要撤销刚才的提交操作，可以使用 --amend 选项重新提交:
```
 $git commit --amend
```
此命令将使用当前的暂存区域快照提交，如果提交完没有做任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，而所提交的文件快照和之前的一样。
```
$git commit -m 'initial commit'
$git add forgotten_file
$git commit --amend
```
上面三条命令最终得到一个提交，第二个提交命令修正了第一个提交的内容。
### 取消已暂存的文件
git add . 全加到了暂存区域。该如何撤销暂存其中的一个文件呢，
```
 $git add .
 $git status
```
可以使用 git reset HEAD<file>的方式取消暂存，
### 取消对文件的修改
```
Changed but not updated:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
modified: benchmarks.rb
```
##远程仓库的使用
### 查看当前的远程库
```
 $git remote
```
### 添加远程仓库
 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]:
```
 $git remote
 origin
 $git remote add pb git://github.com/paulboone/ticgit.git
 $git remote -v
```
现在可以用字符串pb 指定对应的仓库地址值，比如说，要抓取所有Paul有的，但本地仓库么有的信息，可以运行 git fetch pb:
```
 $git fetch pb
```
现在，Paul的主干分支(master)已经完全可以在本地访问了
### 从远程仓库抓取数据
正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地:
```
 $git fetch [remote-name]
```
此命令会到远程仓库中拉去所有你本地仓库中还没有的数据，运行此命令后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。
如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下，所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新(或是上次fetch 以来别人提交的更新)。有一点很重要，fetch 命令只是将远程数据拉到本地仓库，并不自动合并到当前的工作分支，只有当你确实准备好了，才能手动合并。
### 推送数据到远程仓库
```
 git push origin master
```
### 查看远程仓库信息
我们可以通过命令 git remote show [remote-name]查看某个远程仓库的详细信息，比如要看仓库所克隆的 origin仓库，可以运行：
```
 $git remote show origin
```

### 远程仓库的删除和重命名
可以使用 git remote rename 命令修改某个远程仓库的简短名称，比如想把 pb 改成paul 
``` 
 $git remote rename pb paul
 $git remote
```
删除远端仓库
```
$git remote rm paul
$git remote  //查看远端的服务器
```

##打标签
##小技巧和窍门
#git分支
#服务器上的git
#分布式git
#git的工具
#自定义git
#git 内部原理
## 底层命令和高层命令
当你在一个新目录或已有的目录内执行git init时，Git会创建一个.git目录，几乎所有Git存储和操作的内容都位于该目录下，如果你要备份或复制一个库，基本上将这一目录拷贝到该目录下。如果你要备份或负责一个库，基本上将这一目录拷贝到其他地方就可以了。该目录结构如下:
```
$ls
HEAD
branches/
config
description
hooks/
index
info/
objects/
refs/
```
该目录下有可能还有其他文件，但这是一个全新的 git init生成的库，所以默认情况下这些就是你能看到的结构。config文件包含了项目忒有的配置选项，info目录保存了一份不希望在.gitignore文件中管理的忽略模式的全局可执行。objects和refs目录。这些是git的核心部分，objects目录存储所有数据内容，refs目录存储执向数据(分支)的提交对象的指针，HEAD文件指向当前分支，index文件保存了暂存区域信息。

##git 对象
git 是一套内容寻址文件系统，git是简单的key-value数据存储。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候在取出该内容。内容通过底层命令hash-object 来示范这点，传一些数据给该命令，它会将数据保存在.git目录并返回表示这些数据的键值。
```
$ mkdir test
$ cd test
$ git init
$ find .git/ojbects
$ find .git/objects -type f
```
Git 初始化了objects 目录，同时在该目录下创建了pack和info子目录，但是该目录下没有其他常规的文件。我们往这个git数据库里存储一些文本。
```
echo 'test content'|git hash-object -w --stdin
6ea2d9105feab4280a29f2d5c3f06450a68043f9
```
参数-w指示hash-object命令存储对象，若不指定这个参数命令仅仅返回键值。--stdin指定从标准输入设置来读取内容，若不指定这个参数则需指定一个要存储的文件的路径。
```
$find .git/objects -type f
```
可以在objects 目录下看懂一个文件，这便是git存储数据内容的方式，为每份内容生成一个文件，取的该内容与头部信息的SHA-1校验和，创建以该校验和前两个字符为名称的子目录，并以(校验和)剩下38个字符为文件命名（保存到子目录下）。
通过 cat-file命令可以将数据内容取回、该命令是查看git对象的瑞士军刀。
```
git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
```
可以往git中添加更多内容并取回。也可以直接添加文件。
```
nandeMBP:gitTest tuhaisheng$ echo 'version 1' > test.txt
nandeMBP:gitTest tuhaisheng$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
nandeMBP:gitTest tuhaisheng$ echo 'version 2' > test.txt
nandeMBP:gitTest tuhaisheng$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
nandeMBP:gitTest tuhaisheng$ 
```
数据库中已经将文件的两个新版本连同一开始的内容保存下来:
```
nandeMBP:gitTest tuhaisheng$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/6e/a2d9105feab4280a29f2d5c3f06450a68043f9
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```
存储的并不是文件名而仅仅是文件内容。这种对象类型为blob。通过传递SHA-1 值给cat-file-t 命令可以让git 返回任何对象的类型

